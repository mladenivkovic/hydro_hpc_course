#!/users/biernack/Enthought/Canopy_64bit/User/bin/python 
# ^ for python on dora/ela


#!/home/ics/volker/Anaconda/bin/python
# ^ for python on zbox


#/usr/bin/python # use this as shebang if on local machine

# About this script:
#    used by the script hydro-makemovie_parallel_dry to create a 
#    .png file from all output files of a parallel run. Can be 
#    used on its own:
#    hydropic_movie_parallel <outputfiles>
#    <ouputfiles> : all outputfiles from all processors for a 
#    single snapshot, e.g. output_00038.00001 output_00038.00002
#    output_00038.00003 output_00038.00004 (if nproc = 4)
#    It puts the .png output in subdirectory picoutput_parallel.
#    The script requires to be run in the same directory as the
#    hydro output is and needs a hydro_runinfo.txt file, which
#    is generated by the hydro script.




import fortranfile
import numpy
from os import getcwd, path, mkdir #get currend work dir, check if dir exists, make new dir
from sys import argv # command line arguments
from matplotlib import use
use('Agg') #don't show anything unless I ask you to. So no need to get graphical all over ssh.
from matplotlib import pyplot
from matplotlib.colors import LogNorm
from mpl_toolkits.axes_grid1 import make_axes_locatable, axes_size



print "Reading in files."


nx_tot, ny_tot, nproc, nproc_x, nproc_y = numpy.loadtxt('hydro_runinfo.txt',dtype='int', comments='#')

for j in range(0, nproc_y):
    for i in range(0, nproc_x):
        inputfile = str(argv[i+1+j*nproc_x])
        f = fortranfile.FortranFile(inputfile)
        [t, gamma] = f.readReals()
        [nx,ny,nvar,nstep] = f.readInts()
        temp_data = f.readReals()
        f.close()
        
        temp_data = numpy.array(temp_data)
        temp_data = temp_data.reshape(nvar, ny, nx)
        if (i == 0):
            data_x = temp_data
        else:
            data_x = numpy.concatenate((data_x, temp_data), axis=2)
    
    if (j == 0):
        data = data_x
    else:
        data = numpy.concatenate((data, data_x), axis=1)


#determining figure size (figsize)

if (nx_tot > ny_tot):
    bigger=nx_tot
else:
    bigger=ny_tot

figwidth=float(nx_tot)/bigger*12.0
figheight=float(ny_tot)/bigger*12.0




#Plotting
fig = pyplot.figure(facecolor='white', figsize=(figwidth+1, figheight+0.5), dpi=150) 
ax = fig.add_subplot(1,1,1)
#pyplot.tight_layout() #nice layout

print "plotting"

im=ax.imshow(data[0,:,:],interpolation='none',cmap='Blues_r', origin="lower")

#Set axes limits
ax.set_xlim([0, data.shape[2]-1])
ax.set_ylim([0, data.shape[1]-1])

#write only first and last value of axes
ax.axes.get_xaxis().set_ticks([0, data.shape[2]-1])
ax.axes.get_yaxis().set_ticks([0, data.shape[1]-1])

#adjust subplot position in figure
#use this for linear executions
#pyplot.subplots_adjust(left=0.15, right=0.8, top=0.98, bottom=0.1)
#use this for square executions
pyplot.subplots_adjust(left=0.03, right=0.97, top=0.98, bottom=0.07)


#write time
pyplot.figtext(.05, .02, 't='+str(t))

# Make colorbar same height as plot
divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="2%", pad=0.05)
fig.colorbar(im, cax=cax)



workdir = str(getcwd())


outputfilename = 'picoutput_parallel/'+inputfile[:-6]
extension = 'png'
fig_path = workdir+'/'+outputfilename+'.'+extension

print "saving ", fig_path
pyplot.savefig(fig_path, format=extension, facecolor=fig.get_facecolor(), transparent=False, dpi=150)
pyplot.close()

print "hydropic done"

